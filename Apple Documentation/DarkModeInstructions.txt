Overview
In macOS and iOS, users can choose to adopt a system-wide light or dark appearance. The dark appearance, known as Dark Mode, implements an interface style that many apps already adopt. Users choose the aesthetic they prefer, and can also choose to toggle their interface based on ambient lighting conditions or a specific schedule.

All apps should support both light and dark interface styles, but might perform better with a specific appearance in some places. For example, you might always adopt a light appearance for printed content.
Before you change your code, turn on Dark Mode and see how your app responds. The system does a lot of the work for you, and if your app uses standard views and controls, you might not need to make many changes. Standard views and controls automatically update their appearance to match the current interface style. If you already use color and image assets, you can add dark variants without changing your code.

Choose adaptive colors for your UI
Choose colors that adapt automatically to the underlying interface style. Light and dark interfaces use very different color palettes. Colors that work well in a light appearance may be hard to see in a dark appearance, and vice versa. An adaptive color object returns different color values for different interface styles.
There are two ways to create adaptive color objects:
Choose semantic colors instead of fixed color values. When configuring UI elements, choose colors with names like labelColor. These semantic colors convey the intended use of the color, rather than specific color values. When you use them for their intended purpose, they render with color values appropriate for the current settings. For a complete list of semantic color names, see NSColor and UIColor.
Define custom colors in your asset catalog. When you need a specific color, create it as a color asset. In your asset, specify different color values for both light and dark appearances. You can also specify high-contrast versions of your colors.
You configure custom color assets using Xcode’s asset editor. Add a Color Set asset to your project and configure the appearance variants you want to modify. Use the Any Appearance variant to specify the color value to use on older systems that do not support Dark Mode.

To load a color value from an asset catalog, load the color by name:
// macOS
let aColor = NSColor(named: NSColor.Name("customControlColor"))


// iOS
let aColor = UIColor(named: "customControlColor")
When you create a color object from a color asset, you do not have to recreate that object when the current appearance changes. Each time you set the fill or stroke color for drawing, the color object loads the color variant that matches the current environment settings. The same is true for semantic colors such as labelColor, which adapt automatically to the current environment. By contrast, color objects you create using fixed component values do not adapt; you must create a new color object instead.
Note
For the user’s content, always preserve colors that the user explicitly chooses. For example, a painting app should not try to change colors that the user applies to their canvas. Use adaptable colors primarily in the views and controls for your app’s chrome.
Create images for all appearances
Make sure the images in your interface look good in both light and dark appearances. Interfaces use images in many places, including in buttons, image views, and custom views and controls. If an image is difficult to see when changing appearances, provide a new image asset that looks good in the other appearance. Better yet, use a symbol image or template image, which define only the shape to render and therefore do not require separate images for light, dark, and high-contrast environments.

Update custom views using specific methods
When the user changes the system appearance, the system automatically asks each window and view to redraw itself. During this process, the system calls several well-known methods for both macOS and iOS, listed in the following table, to update your content. The system updates the trait environment before calling these methods, so if you make all of your appearance-sensitive changes in these methods, your app updates itself correctly.

NSView -> Appropriate Methods: updateLayer, draw(_:), layout, updateConstraints() UIView -> Appropriate Methods: traitCollectionDidChange(_:), layoutSubviews(), draw(_:), updateConstraints(), tintColorDidChange() UIViewController -> Appropriate Methods: traitCollectionDidChange(_:), updateViewConstraints(), viewWillLayoutSubviews(), viewDidLayoutSubviews() UIPresentationController -> Appropriate Methods: traitCollectionDidChange(_:), containerViewWillLayoutSubviews(), containerViewDidLayoutSubviews()  updateLayer(): @MainActor
func updateLayer()

You use this method to optimize the rendering of your view in situations where you can represent your views contents entirely using a layer object. If your view’s wantsUpdateLayer property is true, the view calls this method instead of draw(_:) during the view update cycle. Custom views can override this method and use it to modify the properties of the underlying layer object. Modifying layer properties is a much more efficient way to update your view than is redrawing its content each time something changes.
When you want to update the contents of your layer, mark the view as dirty by setting its needsDisplay property to true. Doing so adds the view to the list of views that need to be refreshed during the next update cycle. During that update cycle, this method is called if the wantsUpdateLayer property is still true.
Your implementation of this method should not call super.
 draw(_:)
Overridden by subclasses to draw the view’s image within the specified rectangle.
macOS

@MainActor
func draw(_ dirtyRect: NSRect)

Parameters
dirtyRect
A rectangle defining the portion of the view that requires redrawing. This rectangle usually represents the portion of the view that requires updating. When responsive scrolling is enabled, this rectangle can also represent a nonvisible portion of the view that AppKit wants to cache.
Discussion
Use this method to draw the specified portion of your view’s content. Your implementation of this method should be as fast as possible and do as little work as possible. The dirtyRect parameter helps you achieve better performance by specifying the portion of the view that needs to be drawn. You should always limit drawing to the content inside this rectangle. For even better performance, you can call the getRectsBeingDrawn(_:count:) method and use the list of rectangles returned by that method to limit drawing even further. You can also use the needsToDraw(_:) method test whether objects in a particular rectangle need to be drawn.
The default implementation does nothing. Subclasses should override this method if they do custom drawing. Prior to calling this method, AppKit creates an appropriate drawing context and configures it for drawing to the view; you do not need to configure the drawing context yourself. If your app manages content using its layer object instead, use the updateLayer() method to update your layer instead of overriding this method.
If your custom view is a direct NSView subclass, you do not need to call super. For all other views, call super at some point in your implementation so that the parent class can perform any additional drawing.
Important
If the view’s isOpaque property is true, the view must completely fill the dirtyRect rectangle with opaque content.

layout()
Perform layout in concert with the constraint-based layout system.
macOS 10.7+

@MainActor
func layout()

Discussion
Override this method if your custom view needs to perform custom layout not expressible using the constraint-based layout system. In this case you are responsible for setting needsLayout to true when something that impacts your custom layout changes.

You may not invalidate any constraints as part of your layout phase, nor invalidate the layout of your superview or views outside of your view hierarchy. You also may not invoke a drawing pass as part of layout.
You must call [super layout] as part of your implementation.

See Also
Triggering Auto Layout
var needsLayout: Bool
A Boolean value indicating whether the view needs a layout pass before it can be drawn.
func layoutSubtreeIfNeeded()
Updates the layout of the receiving view and its subviews based on the current views and constraints.
var needsUpdateConstraints: Bool
A Boolean value indicating whether the view’s constraints need to be updated.
func updateConstraints()
Update constraints for the view.
func updateConstraintsForSubtreeIfNeeded()
Updates the constraints for the receiving view and its subviews. 

updateConstraints()
Update constraints for the view.
macOS 10.7+

@MainActor
func updateConstraints()

Discussion
Override this method to optimize changes to your constraints.
Note
It is almost always cleaner and easier to update a constraint immediately after the affecting change has occurred. For example, if you want to change a constraint in response to a button press, make that change directly in the button’s action method.
You should only override this method when changing constraints in place is too slow, or when a view is producing a number of redundant changes.
To schedule a change, set the view’s needsUpdateConstraints property to true. The system then calls your implementation of updateConstraints() before the layout occurs. This lets you verify that all necessary constraints for your content are in place at a time when your custom view’s properties are not changing.
Your implementation must be as efficient as possible. Do not deactivate all your constraints, then reactivate the ones you need. Instead, your app must have some way of tracking your constraints, and validating them during each update pass. Only change items that need to be changed. During each update pass, you must ensure that you have the appropriate constraints for the app’s current state.
Do not set the needsUpdateConstraints property inside your implementation. Setting needsUpdateConstraints to true schedules another update pass, creating a feedback loop.

Important
Call [super updateConstraints] as the final step in your implementation.
See Also
var needsLayout: Bool
A Boolean value indicating whether the view needs a layout pass before it can be drawn.
func layout()
Perform layout in concert with the constraint-based layout system.
func layoutSubtreeIfNeeded()
Updates the layout of the receiving view and its subviews based on the current views and constraints.
var needsUpdateConstraints: Bool
A Boolean value indicating whether the view’s constraints need to be updated.
func updateConstraintsForSubtreeIfNeeded()
Updates the constraints for the receiving view and its subviews.

layoutSubviews()
Lays out subviews.

@MainActor
func layoutSubviews()

Discussion
The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you’ve set to determine the size and position of any subviews.
Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews don’t offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.
You shouldn’t call this method directly. If you want to force a layout update, call the setNeedsLayout() method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded() method.
In iOS 18 and later, UIKit supports automatic trait tracking inside this method for traits from this view’s traitCollection.

tintColorDidChange()
Called by the system when the tint color property changes.

@MainActor
func tintColorDidChange()

Discussion
The system calls this method on a view when your code changes the value of the tintColor property on that view. In addition, the system calls this method on a subview that inherits a changed interaction tint color.
In your implementation, refresh the view rendering as needed.

Related Documentation
var tintColor: UIColor!
The first nondefault tint color value in the view’s hierarchy, ascending from and starting with the view itself.
Drawing and updating the view
func draw(CGRect)
Draws the view’s image within the passed-in rectangle.
func setNeedsDisplay()
Marks the receiver’s entire bounds rectangle as needing to be redrawn.
func setNeedsDisplay(CGRect)
Marks the specified rectangle of the receiver as needing to be redrawn.
var contentScaleFactor: CGFloat
The scale factor applied to the view.

updateViewConstraints()
Notifies the view controller when its view needs to update its constraints.

@MainActor
func updateViewConstraints()

Discussion
Override this method to optimize changes to your constraints.
Note
It is almost always cleaner and easier to update a constraint immediately after the affecting change has occurred. For example, if you want to change a constraint in response to a button tap, make that change directly in the button’s action method.
You should only override this method when changing constraints in place is too slow, or when a view is producing a number of redundant changes.
To schedule a change, call setNeedsUpdateConstraints() on the view. The system then calls your implementation of updateViewConstraints() before the layout occurs. This lets you verify that all necessary constraints for your content are in place at a time when your properties are not changing.
Your implementation must be as efficient as possible. Do not deactivate all your constraints, then reactivate the ones you need. Instead, your app must have some way of tracking your constraints, and validating them during each update pass. Only change items that need to be changed. During each update pass, you must ensure that you have the appropriate constraints for the app’s current state.
Do not call setNeedsUpdateConstraints() inside your implementation. Calling setNeedsUpdateConstraints() schedules another update pass, creating a feedback loop.
Important
Call [super updateViewConstraints] as the final step in your implementation.
In iOS 18 and later, UIKit supports automatic trait tracking inside this method for traits from this view controller’s traitCollection and the traitCollection of its view. 

viewWillLayoutSubviews()
Notifies the view controller that its view is about to lay out its subviews.

@MainActor
func viewWillLayoutSubviews()

Discussion
When a view’s bounds change, the view adjusts the position of its subviews. Your view controller can override this method to make changes before the view lays out its subviews. The default implementation of this method does nothing.
In iOS 18 and later, UIKit supports automatic trait tracking inside this method for traits from this view controller’s traitCollection and the traitCollection of its view. 

See Also
View controllers
func updateProperties()
Override point for subclasses to update properties of this view controller or its view. Never call this method directly; use setNeedsUpdateProperties to schedule an update.
func setNeedsUpdateProperties()
Call to manually request a properties update for the view controller. Multiple requests may be coalesced into a single update alongside the next layout pass.
func updatePropertiesIfNeeded()
Forces an immediate properties update for this view controller and its view, including any view controllers and views in this subtree.
func viewDidLayoutSubviews()
Notifies the view controller when its view finishes laying out its subviews.
func updateViewConstraints()
Notifies the view controller when its view needs to update its constraints.
func updateContentUnavailableConfiguration(using: UIContentUnavailableConfigurationState)
Updates the content-unavailable configuration for the provided state.

viewDidLayoutSubviews()
Notifies the view controller when its view finishes laying out its subviews.

@MainActor
func viewDidLayoutSubviews()

Discussion
When the bounds change for a view controller’s view, the view adjusts the positions of its subviews and then the system calls this method. However, this method being called does not indicate that the individual layouts of the view’s subviews have been adjusted. Each subview is responsible for adjusting its own layout.
Your view controller can override this method to make changes after the view lays out its subviews. The default implementation of this method does nothing.
In iOS 18 and later, UIKit supports automatic trait tracking inside this method for traits from this view controller’s traitCollection and the traitCollection of its view. 

See Also
View controllers
func updateProperties()
Override point for subclasses to update properties of this view controller or its view. Never call this method directly; use setNeedsUpdateProperties to schedule an update.
func setNeedsUpdateProperties()
Call to manually request a properties update for the view controller. Multiple requests may be coalesced into a single update alongside the next layout pass.
func updatePropertiesIfNeeded()
Forces an immediate properties update for this view controller and its view, including any view controllers and views in this subtree.
func viewWillLayoutSubviews()
Notifies the view controller that its view is about to lay out its subviews.
func updateViewConstraints()
Notifies the view controller when its view needs to update its constraints.
func updateContentUnavailableConfiguration(using: UIContentUnavailableConfigurationState)
Updates the content-unavailable configuration for the provided state.

containerViewWillLayoutSubviews()
Notifies the presentation controller that layout is about to begin on the views of the container view.

@MainActor
func containerViewWillLayoutSubviews()

Discussion
UIKit calls this method before adjusting the layout of the views in the container view. Use this method and the containerViewDidLayoutSubviews() method to update any custom views managed by your presentation controller.
In iOS 18 and later, UIKit supports automatic trait tracking inside this method for traits from this presentation controller’s traitCollection and the traitCollection of its containerView.

See Also
Presentation controllers
func containerViewDidLayoutSubviews()
Notifies the presentation controller when layout ends on the views of the container view.

containerViewDidLayoutSubviews()
Notifies the presentation controller when layout ends on the views of the container view.

@MainActor
func containerViewDidLayoutSubviews()

UIKit calls this method after adjusting the layout of the views in the container view. Use this method to make any additional changes to the view hierarchy.
In iOS 18 and later, UIKit supports automatic trait tracking inside this method for traits from this presentation controller’s traitCollection and the traitCollection of its containerView. 

See Also
Presentation controllers
func containerViewWillLayoutSubviews()
Notifies the presentation controller that layout is about to begin on the views of the container view.



If you make appearance-sensitive changes outside of these methods, your app may not draw its content correctly for the current environment. The solution is to move your code into these methods. For example, instead of setting the background color of an NSView object’s layer at creation time, move that code to your view’s updateLayer() method instead, as shown in the code example below. Setting the background color at creation time might seem appropriate, but because CGColor objects don’t adapt, setting it at creation time leaves the view with a fixed background color that never changes. Moving your code to updateLayer() refreshes that background color whenever the environment changes.
override func updateLayer() {
   self.layer?.backgroundColor = NSColor.textBackgroundColor.cgColor


   // Other updates.
}
If your app has code that’s not part of an NSView and can’t use the preferred methods listed above, it can observe the app’s effectiveAppearance property and update current manually.
// Use a property to keep a reference to the key-value observation object.
var observation: NSKeyValueObservation?


func applicationDidFinishLaunching(_ aNotification: Notification) {
    observation = NSApp.observe(\.effectiveAppearance) { (app, _) in
        app.effectiveAppearance.performAsCurrentDrawingAppearance {
            // Invoke your non-view code that needs to be aware of the
            // change in appearance.
        }
    }
}


Choose visual-effect materials based on the intended usage
Visual-effect views add transparency to your background views, which gives your UI more visual depth than if the backgrounds were opaque. To ensure that your content remains visible, visual-effect views blur the background content subtly and add vibrancy effects to adjust the colors of your foreground content automatically. The system updates these effects dynamically, ensuring that your app’s content remains visible when the underlying content changes.
Use visual-effect views in your interface as container views, and add subviews to them to represent your foreground content. Configure each visual-effect view with the material or effects that are appropriate for the appearance you want:
In macOS, configure an NSVisualEffectView with the appropriate material based on how you use that view in your interface. For example, when using a visual-effect view as the background for a sidebar interface, configure it with the NSVisualEffectView.Material.sidebar material.
In iOS, configure a UIVisualEffectView with specific vibrancy and blur effects to create the appearance you want. Blur effects define the apparent thickness of the background view, and vibrancy effects adjust the appearance for specific types of content to ensure that they remain visible. For example, when your view contains labels, choose the UIVibrancyEffectStyle.label style or one of the other label-related vibrancy options.
Important
Do not use deprecated materials, such as NSVisualEffectView.Material.light, in macOS 10.14 and later because those materials do not adapt to Dark Mode. Instead, choose newer materials that adapt correctly to the environment.

Avoid expensive tasks during appearance transitions
When the user toggles between light and dark interfaces, the system asks your app to redraw all of its content. Although the system manages the drawing process, it relies on your custom code at several points during that process. Your code must be as quick as possible and not perform tasks unrelated to the appearance change. In macOS, AppKit usually creates transition animations during appearance changes, but it aborts those animations if your app takes too long to redraw itself.

