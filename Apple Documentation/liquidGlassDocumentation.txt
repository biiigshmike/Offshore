If you have an existing app, adopting Liquid Glass doesn’t mean reinventing your app from the ground up. Start by building your app in the latest version of Xcode to see the changes. As you review your app, use the following sections to understand the scope of changes and learn how you can adopt these best practices in your interface.

Use a navigation stack to present a stack of views over a root view. People can add views to the top of the stack by clicking or tapping a NavigationLink, and remove views using built-in, platform-appropriate controls, like a Back button or a swipe gesture. The stack always displays the most recently added view that hasn’t been removed, and doesn’t allow the root view to be removed.
To create navigation links, associate a view with a data type by adding a navigationDestination(for:destination:) modifier inside the stack’s view hierarchy. Then initialize a NavigationLink that presents an instance of the same kind of data. The following stack displays a ParkDetails view for navigation links that present data of type Park:

NavigationStack {
    List(parks) { park in
        NavigationLink(park.name, value: park)
    }
    .navigationDestination(for: Park.self) { park in
        ParkDetails(park: park)
    }
}

Manage navigation state
By default, a navigation stack manages state to keep track of the views on the stack. However, your code can share control of the state by initializing the stack with a binding to a collection of data values that you create. The stack adds items to the collection as it adds views to the stack and removes items when it removes views. For example, you can create a State property to manage the navigation for the park detail view:
@State private var presentedParks: [Park] = []

Initializing the state as an empty array indicates a stack with no views. Provide a Binding to this state property using the dollar sign ($) prefix when you create a stack using the init(path:root:) initializer:
NavigationStack(path: $presentedParks) {
    List(parks) { park in
        NavigationLink(park.name, value: park)
    }
    .navigationDestination(for: Park.self) { park in
        ParkDetails(park: park)
    }
}

Like before, when someone taps or clicks the navigation link for a park, the stack displays the ParkDetails view using the associated park data. However, now the stack also puts the park data in the presentedParks array. Your code can observe this array to read the current stack state. It can also modify the array to change the views on the stack. For example, you can create a method that configures the stack with a specific set of parks:
func showParks() {
    presentedParks = [Park("Yosemite"), Park("Sequoia")]
}

The showParks method replaces the stack’s display with a view that shows details for Sequoia, the last item in the new presentedParks array. Navigating back from that view removes Sequoia from the array, which reveals a view that shows details for Yosemite. Use a path to support deep links, state restoration, or other kinds of programmatic navigation.
Navigate to different view types
To create a stack that can present more than one kind of view, you can add multiple navigationDestination(for:destination:) modifiers inside the stack’s view hierarchy, with each modifier presenting a different data type. The stack matches navigation links with navigation destinations based on their respective data types.
To create a path for programmatic navigation that contains more than one kind of data, you can use a NavigationPath instance as the path.

hiddenTitleBar
A window style which hides both the window’s title and the backing of the titlebar area, allowing more of the window’s content to show.
macOS 11.0+
static var hiddenTitleBar: HiddenTitleBarWindowStyle { get }
Available when Self is HiddenTitleBarWindowStyle.

toolbar(content:)
Populates the toolbar or navigation bar with the specified items.

nonisolated
func toolbar<Content>(@ToolbarContentBuilder content: () -> Content) -> some View where Content : ToolbarContent

nonisolated
func toolbar<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View

Use this modifier to add content to the toolbar. The toolbar modifier expects a collection of toolbar items that you can provide either by supplying a collection of views with each view wrapped in a ToolbarItem, or by providing a collection of views as a ToolbarItemGroup. The example below adds views to using a toolbar item group to support text editing features:

struct StructToolbarItemGroupView: View {
    @State private var text = ""
    @State private var bold = false
    @State private var italic = false
    @State private var fontSize = 12.0


    var displayFont: Font {
        let font = Font.system(size: CGFloat(fontSize),
                               weight: bold == true ? .bold : .regular)
        return italic == true ? font.italic() : font
    }


    var body: some View {
        TextEditor(text: $text)
            .font(displayFont)
            .toolbar {
                ToolbarItemGroup {
                    Slider(
                        value: $fontSize,
                        in: 8...120,
                        minimumValueLabel:
                            Text("A").font(.system(size: 8)),
                        maximumValueLabel:
                            Text("A").font(.system(size: 16))
                    ) {
                        Text("Font Size (\(Int(fontSize)))")
                    }
                    .frame(width: 150)
                    Toggle(isOn: $bold) {
                        Image(systemName: "bold")
                    }
                    Toggle(isOn: $italic) {
                        Image(systemName: "italic")
                    }
                }
            }
            .navigationTitle("My Note")
    }
}

UINavigationBar
Navigational controls that display in a bar along the top of the screen, usually in conjunction with a navigation controller.

@MainActor
class UINavigationBar

A UINavigationBar object is a bar, typically displayed at the top of the window, containing buttons for navigating within a hierarchy of screens. The primary components are a left (back) button, a center title and optional subtitle, and optional right button(s). You can use a navigation bar as a standalone object or in conjunction with a navigation controller object.
You most frequently use a navigation bar within a navigation controller. The UINavigationController object creates, displays, and manages its associated navigation bar, and uses attributes of the view controllers you add to control the content displayed in the navigation bar.
To control a navigation bar when using a navigation controller, follow these steps:
Create a navigation controller in Interface Builder or in the code.
Configure the appearance of the navigation bar using the navigationBar property on the UINavigationController object.
Control the content of the navigation bar by setting the title and navigationItem properties on each UIViewController you push onto the navigation controller’s stack.
You can also use a standalone navigation bar, without using a navigation controller. To add a navigation bar to your interface, follow these steps:
Set up Auto Layout rules to govern the position of the navigation bar in your interface.
Create a root navigation item to supply the initial title.
Configure a delegate object to handle user interactions with the navigation bar.
Customize the appearance of the navigation bar.
Configure your app to push and pop relevant navigation items as the user navigates through the hierarchical screens.

Use a navigation bar with a navigation controller
If you use a navigation controller to manage the navigation between different screens of content, the navigation controller creates a navigation bar automatically and pushes and pops navigation items when appropriate.
A navigation controller uses the navigationItem property on UIViewController to provide the model objects to its navigation bar when navigating a stack of view controllers. The default navigation item uses the view controller’s title, but you can override the navigationItem on a UIViewController subclass to gain complete control of the navigation bar’s content.
A navigation controller automatically assigns itself as the delegate of its navigation bar object. Therefore, when using a navigation controller, don’t assign a custom delegate object to the corresponding navigation bar.
To access the navigation bar associated with a navigation controller, use the navigationBar property on UINavigationController. See Customize the appearance of a navigation bar for details on appearance customization.
For more information about navigation controllers, see UINavigationController.

Add content to a standalone navigation bar
In the vast majority of scenarios, you use a navigation bar as part of a navigation controller. However, there are situations for which you might want to use the navigation bar UI and implement your own approach to content navigation. In these situations, you can use a standalone navigation bar.
When you use a navigation bar as a standalone object, you’re responsible for providing its content. Unlike other types of views, you don’t add subviews to a navigation bar directly. Instead, you use a navigation item (an instance of the UINavigationItem class) to specify what buttons or custom views you want displayed. A navigation item has properties for specifying views on the left, right, and center of the navigation bar and for specifying a custom prompt string.
A navigation bar manages a stack of UINavigationItem objects. Although the stack is there mostly to support navigation controllers, you can use it to implement your own custom navigation interface. The topmost item in the stack represents the navigation item whose contents are currently displayed by the navigation bar. You push new navigation items onto the stack using the pushItem(_:animated:) method and pop items off the stack using the popItem(animated:) method. Both of these changes can be animated for the benefit of the user.
In addition to pushing and popping items, you can also set the contents of the stack directly using either the items property or the setItems(_:animated:) method. You might use this method at launch time to restore your interface to its previous state or to push or pop more than one navigation item at a time. The following figure shows the part of the UINavigationBar API responsible for managing the stack of navigation items:

If you’re using a navigation bar as a standalone object, assign a custom delegate object to the delegate property and use that object to intercept messages coming from the navigation bar. Delegate objects must conform to the UINavigationBarDelegate protocol. The delegate notifications let you track when navigation items are pushed or popped from the stack. You use these notifications to update the rest of your app’s user interface.
For more information about creating navigation items, see UINavigationItem. For more information about implementing a delegate object, see UINavigationBarDelegate.

Customize the appearance of a navigation bar
Navigation bars are transparent and feature bar button items constructed with Liquid Glass. Don’t add a background or apply a tint color to the navigation bar, as that may interfere with the Liquid Glass presentation.
Customize the color of the text or image in a bar button item by setting the tintColor property. To customize the background color of a bar button item, set the bar button’s tint color, then set the bar button’s style property to the value UIBarButtonItem.Style.prominent.
The titleTextAttributes property specifies the attributes for displaying the bar’s title text. You can specify the font, text color, text shadow color, and text shadow offset for the title in the text attributes dictionary using the NSFontAttributeName, NSForegroundColorAttributeName, and NSShadowAttributeName keys.
Use the setTitleVerticalPositionAdjustment(_:for:) method to adjust the vertical position of the title. This method allows you to specify the adjustment dependent on the bar height, which is represented by the UIBarMetrics enumeration.
See Customizing your app’s navigation bar for customization examples.

Customize a navigation bar with Interface Builder
The following table lists the Interface Builder attributes that affect the appearance of the navigation bar’s title.

Title Font: The font for the title in the center of the navigation bar. Access this value at runtime with the NSFontAttributeName key in the titleTextAttributes dictionary.

Title Color: The color for the navigation bar title. Access this value at runtime with the NSForegroundColorAttributeName key in the titleTextAttributes dictionary.

Title Shadow: The color and offset of the shadow for the navigation bar’s title. Access these values at runtime from the titleTextAttributes dictionary, using the NSShadowAttributeName key.

Responding to navigation bar changes
var delegate: (any UINavigationBarDelegate)?
The navigation bar’s delegate object.
protocol UINavigationBarDelegate
Methods that a navigation bar calls before and after it modifies its stack of navigation items.

Pushing and popping items
func pushItem(UINavigationItem, animated: Bool)
Pushes the given navigation item onto the navigation bar’s stack and updates the UI.
func popItem(animated: Bool) -> UINavigationItem?
Pops the top item from the navigation bar’s stack and updates the UI.
func setItems([UINavigationItem]?, animated: Bool)
Replaces the navigation items currently managed by the navigation bar with the specified items.
var items: [UINavigationItem]?
An array of navigation items managed by the navigation bar.
var topItem: UINavigationItem?
The navigation item at the top of the navigation bar’s stack.
var backItem: UINavigationItem?
The navigation item that is immediately below the topmost item on a navigation bar’s stack.

Customizing the bar’s appearance
var prefersLargeTitles: Bool
A Boolean value that indicates whether the title displays in a large format.
var standardAppearance: UINavigationBarAppearance
The appearance settings for a standard-height navigation bar.
var compactAppearance: UINavigationBarAppearance?
The appearance settings for a compact-height navigation bar.
var scrollEdgeAppearance: UINavigationBarAppearance?
The appearance settings for the navigation bar when the edge of scrollable content aligns with the edge of the navigation bar.
var compactScrollEdgeAppearance: UINavigationBarAppearance?
The appearance settings for a compact-height navigation bar when the edge of scrollable content aligns with the edge of the navigation bar.
var isTranslucent: Bool
A Boolean value that indicates whether the navigation bar is translucent.

Building with Mac Catalyst
var behavioralStyle: UIBehavioralStyle
The behavioral style of the navigation bar.
var preferredBehavioralStyle: UIBehavioralStyle
The preferred behavioral style of the navigation bar.
var currentNSToolbarSection: UINavigationBar.NSToolbarSection
The toolbar section that the navigation bar is currently using.
enum NSToolbarSection
Constants that determine how the system hosts the navigation bar in an AppKit toolbar.

UIToolbar
A control that displays one or more buttons along an edge of your interface.
iOS 2.0+
iPadOS 2.0+
Mac Catalyst 13.1+
visionOS 1.0+
@MainActor
class UIToolbar
Overview
To create toolbar items, use the UIBarButtonItem class. To add toolbar items to a toolbar, use the setItems(_:animated:) method.
Toolbar images that represent normal and highlighted states of an item derive from the image you set using the inherited image property from the UIBarItem class. The toolbar’s tintColor colors the image.
If you need radio button style controls, use the UITabBar class instead of UIToolbar.
When the system presents the toolbar with Liquid Glass:
Don’t apply custom backgrounds or appearances to UIToolbar. Instead, let the system determine the background appearance.
Don’t use UIToolbar directly when you present your view controller with a UINavigationController. Instead, set toolbarItems to get system-provided transitions and animations in your toolbar.
*Note: In iOS 18 and earlier, you use the methods listed in Customizing appearance to customize the appearance of toolbars. You send the setter messages to the appearance proxy (UIToolbar.appearance() in Swift or [UIToolbar appearance] in Objective-C) to customize all toolbars, or to a specific UIToolbar instance. If a property is dependent on the bar metrics, specify a value for UIBarMetrics.default as well as for UIBarMetrics.compact.

Split the toolbar’s shared background
By default, the system organizes all of the buttons you provide into one grouping that shares a background in the toolbar. To split buttons into different groupings with separate shared backgrounds, add fixedSpace() between buttons to indicate where you want to split the shared background.
For a button that finalizes or completes a task, set the button’s style to UIBarButtonItem.Style.prominent so that the system can avoid visually grouping the button with other buttons.

Topics
Managing toolbar changes
var delegate: (any UIToolbarDelegate)?
The toolbar’s delegate object.
protocol UIToolbarDelegate
The interface that toolbar delegate objects implement to manage the toolbar behavior.
Configuring toolbar items
var items: [UIBarButtonItem]?
The items displayed on the toolbar.
func setItems([UIBarButtonItem]?, animated: Bool)
Sets the items on the toolbar by animating the changes.
Customizing appearance
var standardAppearance: UIToolbarAppearance
The appearance settings to use for a standard-height toolbar.
var compactAppearance: UIToolbarAppearance?
The appearance settings to use for a compact-height toolbar.
var scrollEdgeAppearance: UIToolbarAppearance?
The appearance settings for a standard-height toolbar when the edge of scrollable content aligns with the edge of the toolbar.
var compactScrollEdgeAppearance: UIToolbarAppearance?
The appearance settings for a compact-height toolbar when the edge of any scrollable content aligns with the edge of a compact-height toolbar.
var isTranslucent: Bool
A Boolean value that indicates whether the toolbar is translucent.

UITabBar
A control that displays one or more buttons in a tab bar for selecting between different subtasks, views, or modes in an app.

@MainActor
class UITabBar

Overview
Typically, you use tab bars in conjunction with a UITabBarController object, but you can also use them as standalone controls in your app. Tab bars always appear across the bottom edge of the screen and display the contents of one or more UITabBarItem objects. A tab bar’s appearance can be customized with a background image or tint color to suit the needs of your interface. Tapping an item selects and highlights that item, and you use the selection of the item to enable the corresponding mode for your app.
You can configure tab bars programmatically or in Interface Builder. A UITabBarController object provides its own tab bar object and you must configure the object provided to you. When creating a tab bar programmatically, use the init(frame:) method or another view initializer method to set its initial configuration. Use the methods of this class to configure the appearance of the tab bar. For tab bars you create yourself, you also use the methods of this class to specify the items displayed by the tab bar.
Note
The UITabBar class and UIToolbar classes have similar appearances but different purposes. Use tab bars to convey and change your app’s mode. Use toolbars to present the user with a set of actions that are relevant to the currently presented content.

A tab bar reports selections and user customizations to its delegate object. For tab bars you create yourself, use the delegate to respond to selections or to the addition, removal, or reordering of items in the tab bar. (A UITabBarController object acts as the delegate for the tab bar it manages.) For more information on implementing a tab bar delegate, see UITabBarDelegate.
Configure the tab bar items
You can configure tab bar items using Interface Builder or create and configure them programmatically in your code. Tab bars in Interface Builder come preconfigured with some initial items and you can add, remove, or reorder items as needed. How you configure items at design time depends on whether your tab bar is associated with a UITabBarController object:
Configuring your tab bar in Interface Builder:
When a UITabBarController object is present, add or remove view controllers to your scene and create relationship segues between the tab bar controller and each new view controller. Creating a relationship segue automatically adds a new item to the tab bar, and deleting an existing relationship segue removes the corresponding tab bar item.
When a tab bar controller isn’t present, drag tab bar items from the library onto your tab bar.
Configuring your tab bar programmatically:
To configure the tab bar associated with a UITabBarController object, configure the view controllers associated with the tab bar controller. The tab bar automatically obtains its items from the tabBarItem property of each view controller associated with the tab bar controller.
To configure tab bar items directly, use the setItems(_:animated:) method of the tab bar itself.
A tab bar displays all of its tabs onscreen at once, using the itemPositioning property to determine how to position items in the available space. If you have more items than can fit in the available space, display only a subset of them and let the user select which tabs are displayed. The beginCustomizingItems(_:) method displays an interface for selecting which tab bar items to display.
The contents of each item are stored in a UITabBarItem object. Each item contains a title and an image to display in the tab. You can also use tab bar items to add a badge to the corresponding tab. For more information about creating and configuring items, see UITabBarItem.
Respond to tab selections
For tab bars with an associated tab bar controller, the tab bar controller automatically manages selections and displays the appropriate view controller. The only time you have to manage selections yourself is when you create the tab bar without a tab bar controller. The tab bar reports selections to the tabBar(_:didSelect:) method of its delegate object, which you can use to respond to selection changes. For more information about implementing the delegate object, see UITabBarDelegate.

Configure a tab bar with Interface Builder
The following table lists the attributes that you configure for tab bars in Interface Builder.

Background: The background image to display for the bar. If you specify a stretchable image, the image is stretched to fit the available space; otherwise, the image is tiled. When you configure a background image, the tab bar ignores the tint color information. To set this attribute programmatically, use the backgroundImage property.

Shadow: The custom shadow image for the tab bar. This attribute is ignored if the tab bar does not also have a custom background image. To set this attribute programmatically, use the shadowImage property.

Selection: The image to use for the selected tab. To set this attribute programmatically, use the selectionIndicatorImage property.

Image Tint: The tint color to apply to the selected item. To set this attribute programmatically, use the tintColor property.

Style: The basic style to apply to the bar. You can configure a tab bar with a dark or light style and the bar can be opaque or translucent. To set the style programmatically, use the barStyle and isTranslucent properties.

Bar Tint: The tint color to apply to the bar. To set this attribute programmatically, use the barTintColor property.

Item Positioning: The positioning scheme to apply to items. Use this attribute to configure how items are spaced across the length of the tab bar. To set this attribute programmatically, use the itemPositioning property.

Customizing the tab bar behavior
var delegate: (any UITabBarDelegate)?
The tab bar’s delegate object.
protocol UITabBarDelegate
The UITabBarDelegate protocol defines optional methods for a delegate of a UITabBar object. The UITabBar class provides the ability for the user to reorder, remove, and add items to the tab bar; this process is referred to as customizing the tab bar. The tab bar delegate receives messages when customizing occurs.
Configuring tab bar items
var items: [UITabBarItem]?
The items displayed by the tab bar.
func setItems([UITabBarItem]?, animated: Bool)
Sets the items on the tab bar, optionally animating any changes into position.
var selectedItem: UITabBarItem?
The currently selected item on the tab bar.
Customizing tab bar appearance
var standardAppearance: UITabBarAppearance
The appearance settings for a standard-height tab bar.
var scrollEdgeAppearance: UITabBarAppearance?
The appearance settings for the tab bar when the edge of scrollable content aligns with the edge of the tab bar.
var leadingAccessoryView: UIView
The view at the leading edge of a tab bar on tvOS.
var trailingAccessoryView: UIView
The view at the trailing edge of a tab bar on tvOS.
var isTranslucent: Bool
A Boolean value that indicates whether the tab bar is translucent.

NSToolbar
An object that manages the space above your app’s custom content and either below or integrated with the window’s title bar.

@MainActor
class NSToolbar

Overview
An NSToolbar object manages the controls and views that apply to the main window’s content area. Toolbars provide convenient access to the commands and features people use most often. Toolbars are also user-configurable and support the display of an interactive customization palette.
Create and configure your toolbar programmatically or using Interface Builder. Add items to the toolbar that correspond to the commands you want to feature in your window. Each item has a corresponding NSToolbarItem object, which you use to make changes. Each toolbar manages a unique set of items, but you can synchronize the items and state of multiple toolbars by assigning the same value to their identifier properties.
For more information about how to use toolbars, see Integrating a Toolbar and Touch Bar into Your App.

Creating an toolbar object
init(identifier: NSToolbar.Identifier)
Creates a newly allocated toolbar with the specified identifier.
convenience init()
Creates a new toolbar with an empty identifier string.
Configuring the toolbar contents
var delegate: (any NSToolbarDelegate)?
The object you use to customize the toolbar contents and configuration.
protocol NSToolbarDelegate
A set of optional methods you use to configure the toolbar and respond to changes.
Getting the toolbar’s identity
var identifier: NSToolbar.Identifier
The value you use to identify the toolbar in your app.
typealias Identifier
A string value that you use to differentiate your app’s toolbars.
Configuring the toolbar’s behavior
var isVisible: Bool
A Boolean value that indicates whether the toolbar is visible.
var displayMode: NSToolbar.DisplayMode
A value that indicates whether the toolbar displays items using a name, icon, or combination of elements.
enum DisplayMode
Constants that indicate whether the toolbar displays items using a name, icon, or combination of elements.
var showsBaselineSeparator: Bool
A Boolean value that indicates whether the toolbar shows the separator between the toolbar and the main window contents. ( Deprecated )
var allowsUserCustomization: Bool
A Boolean value that indicates whether users can modify the contents of the toolbar.
var allowsExtensionItems: Bool
A Boolean value that indicates whether the toolbar can add items for Action extensions.
Managing items on the toolbar
var items: [NSToolbarItem]
An array containing the toolbar’s current items, in order.
var visibleItems: [NSToolbarItem]?
An array containing the toolbar’s currently visible items.
var centeredItemIdentifiers: Set<NSToolbarItem.Identifier>
The set of custom items to display in the center of the toolbar.
var selectedItemIdentifier: NSToolbarItem.Identifier?
The identifier of the toolbar’s currently selected item.
class let willAddItemNotification: NSNotification.Name
Posts before the toolbar adds a new item.
class let didRemoveItemNotification: NSNotification.Name
Posted after an item is removed from a toolbar.
func insertItem(withItemIdentifier: NSToolbarItem.Identifier, at: Int)
Inserts an item into the toolbar at the specified index.
func removeItem(at: Int)
Removes the item at the specified index in the toolbar.
Autosaving the configuration
var autosavesConfiguration: Bool
A Boolean value that indicates whether the toolbar autosaves its configuration.
var configuration: [String : Any]
A dictionary containing the current configuration details for the toolbar. (Deprecated)
func setConfiguration([String : Any])
Specifies the new configuration details for the toolbar. (Deprecated)
Displaying the customization palette
func runCustomizationPalette(Any?)
Displays the toolbar’s customization palette and handles any user-initiated customizations.
var customizationPaletteIsRunning: Bool
A Boolean value that indicates whether the toolbar’s customization palette is in use.
Validating visible items
func validateVisibleItems()
Validates the toolbar’s visible items during a window update.

The following methods all seem to be deprecated: 
Deprecated
var centeredItemIdentifier: NSToolbarItem.Identifier?
The item to display in the center of the toolbar.
Deprecated
var fullScreenAccessoryView: NSView?
The toolbar’s full screen accessory view.
Deprecated
var fullScreenAccessoryViewMinHeight: CGFloat
The minimum height of the toolbar’s full screen accessory view.
Deprecated
var fullScreenAccessoryViewMaxHeight: CGFloat
The maximum height of the toolbar’s full screen accessory view, in points.
Deprecated
var sizeMode: NSToolbar.SizeMode
The toolbar’s size mode.
Deprecated
enum SizeMode
Constants that specify toolbar display modes.
Deprecated

Instance Properties
var allowsDisplayModeCustomization: Bool
Whether or not the user is allowed to change display modes at run time. This functionality is independent of customizing the order of the items themselves. Only disable when the functionality or legibility of your toolbar could not be improved by another display mode. The user’s selection will be persisted using the toolbar’s identifier when autosavesConfiguration is enabled. The default is YES for apps linked on macOS 15.0 and above.
var itemIdentifiers: [NSToolbarItem.Identifier]
An array of itemIdentifiers that represent the current items in the toolbar. Setting this property will set the current items in the toolbar by diffing against items that already exist. Use this with great caution if allowsUserCustomization is enabled as it will override any customizations the user has made. This property is key value observable.
Instance Methods
func removeItem(identifier: NSToolbarItem.Identifier)
Removes the item with matching itemIdentifier in the receiving toolbar. If multiple items share the same identifier (as is the case with space items) all matching items will be removed. To remove only a single space item, use -removeItemAtIndex: instead.
