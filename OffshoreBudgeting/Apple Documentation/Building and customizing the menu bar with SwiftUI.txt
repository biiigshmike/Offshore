Building and customizing the menu bar with SwiftUI
Provide a seamless, cross-platform user experience by building a native menu bar for iPadOS and macOS.

Overview
On iPadOS and macOS, the menu bar provides access to crucial system-provided actions, such as Cut, Copy, Paste, and window management. The system groups these actions by function into menus and submenus through the menu bar. Apps can add contextual actions, like showing and hiding a sidebar, and can also create custom menus and menu items to allow people to perform app-specific actions from the menu bar. You can also bind menu bar to keyboard shortcuts to make your app quicker and easier to use.

Apps include instances of Scene which display the main views of the app. Each scene provides different default menu sets and actions in the menu bar. Contextually relevant menus and actions, and even custom menus and actions, are specified with the commands(content:) modifier.
The order of system-provided menus and menu items is consistent across all apps, but some menus and menu items are added depending on context. For example, document-based apps include options in the File menu for creating and opening documents. Similarly, not all apps include text-formatting capabilities, but those that include text editing views get a Format menu with options for choosing fonts and styling text by including TextFormattingCommands in the scene’s commands. The system will then add the appropriate menu groups and items that people expect in this context.
Think about how someone uses your app and which actions make sense to add to the menu bar and where to place them. 

Populate the menu bar
When your app launches, the menu bar populates with menus and menu items based on the implemented scenes and commands. Menu items for conditional or context-dependent commands are made active or inactive dynamically, using information from the active scene and its view hierarchy in focus.
Each scene includes a set of default menus and menu items, which you can supplement with your own app-specific needs using the commands(content:) modifier.
A scene’s default menus and menu items are dependent on the functionality the scene type supports. For example, WindowGroup includes commands for quitting and hiding the app, as well as Copy and Paste support and window management.

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

On macOS, the Settings scene includes the same actions as Window, but adds an action for presenting the app’s Settings window that people get when they choose App menu > Settings. On iPadOS, this menu bar item doesn’t require an additional scene and when performed; it switches to the app’s settings in the Settings app.

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }


        #if os(macOS)
        Settings {
            SettingsView()
        }
        #endif
    }
}

The DocumentGroup scene includes actions that WindowGroup includes, as well as a number of actions that support document management capabilities, like Save and Duplicate.
Using scenes together creates a menu bar that includes menu items for all of the core functionality of an app that creates and edits documents, manages multiple windows, and exposes user-configurable settings.

@main
struct MyApp: App {
    var body: some Scene {
        DocumentGroup(newDocument: MyAppDocument()) { file in
            // ...
        }


        #if os(macOS)
        Settings {
            // ...
        }
        #endif
    }
}

Add contextual system-provided menu items
Some common menu items are optional, but are helpful if the app contains certain capabilities. For example, not every scene includes a navigation sidebar, but for those that do, people expect to find a menu item that controls the navigation sidebar’s visibility. If your scene includes a navigation sidebar, include this menu item using the commands(content:) modifier and implementing SidebarCommands:

@main
struct MyApp: App {
    var body: some Scene {
        DocumentGroup(newDocument: MyAppDocument()) { file in
            ContentView(document: file.$document)
        }
        .commands {
            SidebarCommands()
        }
    }
}

For more information on system-provided command groups, such as text formatting, toolbars, and inspectors, see Commands at the bottom of this document.



Create custom menus and menu items
Organize and group your app’s custom menu items in custom menus using CommandMenu. The system inserts custom menus into the menu bar after the View menu.
Custom menu items are created with standard SwiftUI views, for example Button and Toggle. Menu creates a submenu. For more information about menu item creation, see Populating SwiftUI menus with adaptive controls.
The menu bar also displays information about keyboard shortcuts next to menu items and which keys someone needs to press on the keyboard to perform an action without using the menu bar. The keyboardShortcut(_:) modifier allows you to define which key combination will perform the action. Be aware that the system provides many keyboard shortcuts that your app can’t override.

WindowGroup {
    ContentView()
}
.commands {
    CommandMenu("Actions") {
        Button("Run", systemImage: "play.fill") { ... }
            .keyboardShortcut("R")


        Button("Stop", systemImage: "stop.fill") { ... }
            .keyboardShortcut(".")
    }
}

Modify standard menus
Modify system-provided menus using CommandGroup. These groups either extend menus with additional menu items or they replace existing menu items in the indicated command group. When you add menu items in this way, you can specify the location of the menu item based on system-provided menu items.

WindowGroup {
    ContentView()
}
.commands {
    CommandGroup(before: .systemServices) {
        Button("Check for Updates") { ... }
    }
    
    CommandGroup(after: .newItem) {
        Button("New from Clipboard") { ... }
    }
    
    CommandGroup(replacing: .help) {
        Button("User Manual") { ... }
    }
}

Update menus and menu items dynamically
Many menu items update their appearance or action depending on whether the scene is active, if the scene has focus, or what is currently selected. For example, the system grays out the Close Window command in the File menu when the app’s last window closes. Similarly, the Cut and Copy menu items are only available in the active window if the person selects copyable data. This behavior also applies to custom menus and menu items your app provides.
Use FocusedValue to create contextual dependencies with your menus and menu items. For example, a menu item’s title can change if the current focus is on a photo or a photo album. A focused value is state data that requires an active scene with its view hierarchy in focus. Use a dynamic property to react to changes in the views of the scene.
In the following, an app with a WindowGroup scene has an Observable() data model for each window that supplies that window’s contents. The active window’s data model is made available as a focused value using the focusedSceneValue(_:) modifier in the window view hierarchy.

@Observable
final class DataModel {
    var messages: [Message]
    ...
}


struct ContentView: View {
    @State private var model = DataModel()


    var body: some View {
        VStack {
            ForEach(model.messages) { ... }
        }
        .focusedSceneValue(model)
    }
}

Use the FocusedValue property wrapper to represent the active scene’s data model in the menu bar. The data model changes whether the “New Message” button is active or inactive:

struct MessageCommands: Commands {
    @FocusedValue(DataModel.self) private var dataModel: DataModel?


    var body: some Commands {
        CommandGroup(after: .newItem) {
            Button("New Message") {
                dataModel?.messages.append(...)
            }
            .disabled(dataModel == nil)
        }
    }
}


@main struct MessagesApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .commands {
            MessageCommands()
        }
    }
}

Similar to the Environment dynamic property, FocusedValue uses a key you provide to find the current value. When the focused value is an Observable object, that key can simply be the object’s type.
To share value-typed values, extend FocusedValues with a custom entry using the Entry() macro, and pass the resulting key path when declaring the FocusedValue property. Custom entry values must always be optional.

struct ContentView: View {
    @State private var items: [Item] = ...
    @State private var selection: UUID?
    
    var body: some View {
        List(items, selection: $selection) { item in
            ...
        }
        // When active, views in the same scene or in the menu bar
        // can read the selected item ID.
        .focusedSceneValue(\.selectedItemID, selection)
    }
}


struct ItemCommands: Commands {
    @FocusedValue(\.selectedItemID) var selectedItemID: UUID?
    
    var body: some Commands {
        ...
    }
}


extension FocusedValues {
    @Entry var selectedItemID: UUID?
}

Use focusedValue(_:) when a menu item depends on the current placement of focus within the active scene’s view hierarchy. This creates a focused value that’s’ only visible to other views when focus is on the modified view or one of its subviews. When focus is elsewhere, the value of corresponding FocusedValue property is nil.

struct ContentView: View {
    @State private var items: [Item] = ...
    @State private var selection: UUID?


    var body: some View {
        NavigationSplitView {
            SidebarContent()
        } detail: {
            List(items, selection: $selection) { item in
                ...
            }


            // The selected item ID is visible when focus is on the 
            // navigation detail list. If focus is on the sidebar, the value of 
            // `@FocusedValue(\.selectedItemID)` is `nil`.
            .focusedValue(\.selectedItemID, selection)
        }
    }
}

Commands
Conforming types represent a group of related commands that can be exposed to the user via the main menu on macOS and key commands on iOS.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

@MainActor @preconcurrency
protocol Commands

Overview
A type conforming to this protocol inherits @preconcurrency @MainActor isolation from the protocol if the conformance is included in the type’s base declaration:

struct MyCustomType: Transition {
    // `@preconcurrency @MainActor` isolation by default
}

Isolation to the main actor is the default, but it’s not required. Declare the conformance in an extension to opt out of main actor isolation:

extension MyCustomType: Transition {
    // `nonisolated` by default
}

Implementing commands
var body: Self.Body
The contents of the command hierarchy.
Required

associatedtype Body : Commands
The type of commands that represents the body of this command hierarchy.
Required

Defining commands

func commands<Content>(content: () -> Content) -> some Scene
Adds commands to the scene.

commands(content:)
Adds commands to the scene.

nonisolated
func commands<Content>(@CommandsBuilder content: () -> Content) -> some Scene where Content : Commands

Commands are realized in different ways on different platforms. On macOS, the main menu uses the available command menus and groups to organize its main menu items. Each menu is represented as a top-level menu bar menu, and each command group has a corresponding set of menu items in one of the top-level menus, delimited by separator menu items.
On iPadOS, commands with keyboard shortcuts are exposed in the shortcut discoverability HUD that users see when they hold down the Command (⌘) key.

--

func commandsRemoved() -> some Scene
Removes all commands defined by the modified scene.

commandsRemoved()
Removes all commands defined by the modified scene.
iOS 16.0+
iPadOS 16.0+
Mac Catalyst 16.0+
macOS 13.0+
visionOS 1.0+

Return Value
A scene that excludes any commands defined by its children.

WindowGroup, Window, and other scene types all have an associated set of commands that they include by default. Apply this modifier to a scene to exclude those commands.
For example, the following code adds a scene for presenting the details of an individual data model in a separate window. To ensure that the window can only appear programmatically, we remove the scene’s commands, including File > New Note Window.

@main
struct Example: App {
    var body: some Scene {
        ...


        WindowGroup("Note", id: "note", for: Note.ID.self) {
            NoteDetailView(id: $0)
        }
        .commandsRemoved()
    }
}

--

func commandsReplaced<Content>(content: () -> Content) -> some Scene
Replaces all commands defined by the modified scene with the commands from the builder.

commandsReplaced(content:)
Replaces all commands defined by the modified scene with the commands from the builder.
iOS 16.0+
iPadOS 16.0+
Mac Catalyst 16.0+
macOS 13.0+
visionOS 1.0+

nonisolated
func commandsReplaced<Content>(@CommandsBuilder content: () -> Content) -> some Scene where Content : Commands

Parameters

content
A Commands builder whose output will be used to replace the commands normally provided by the modified scene.

Return Value
A scene that replaces any commands defined by its children with alternative content.

WindowGroup, Window, and other scene types all have an associated set of commands that they include by default. Apply this modifier to a scene to replace those commands with the output from the given builder.
For example, the following code adds a scene for showing the contents of the pasteboard in a dedicated window. We replace the scene’s default Window > Clipboard menu command with a custom Edit > Show Clipboard command that we place next to the other pasteboard commands.

@main
struct Example: App {
    @Environment(\.openWindow) var openWindow


    var body: some Scene {
        ...


        Window("Clipboard", id: "clipboard") {
            ClipboardContentView()
        }
        .commandsReplaced {
            CommandGroup(after: .pasteboard) {
                Section {
                    Button("Show Clipboard") {
                        openWindow(id: "clipboard")
                    }
                }
            }
        }
    }
}

--

struct CommandMenu
Command menus are stand-alone, top-level containers for controls that perform related, app-specific commands.

CommandMenu
Command menus are stand-alone, top-level containers for controls that perform related, app-specific commands.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

struct CommandMenu<Content> where Content : View

Overview
Command menus are realized as menu bar menus on macOS, inserted between the built-in View and Window menus in order of declaration. On iOS, iPadOS, and tvOS, SwiftUI creates key commands for each of a menu’s commands that has a keyboard shortcut.

Creating a command menu

init(_:content:)
Creates a new menu with a localized name for a collection of app- specific commands, inserted in the standard location for app menus (after the View menu, in order with other menus declared without an explicit location).

--

struct CommandGroup
Groups of controls that you can add to existing command menus.

CommandGroup
Groups of controls that you can add to existing command menus.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

In macOS, SwiftUI realizes command groups as collections of menu items in a menu bar menu. In iOS, iPadOS, and tvOS, SwiftUI creates key commands for each of a group’s commands that has a keyboard shortcut.

Creating a command group
init(after: CommandGroupPlacement, addition: () -> Content)
A value describing the addition of the given views to the end of the indicated group.

init(
    after group: CommandGroupPlacement,
    @ViewBuilder addition: () -> Content
)

init(before: CommandGroupPlacement, addition: () -> Content)
A value describing the addition of the given views to the beginning of the indicated group.

init(
    before group: CommandGroupPlacement,
    @ViewBuilder addition: () -> Content
)

init(replacing: CommandGroupPlacement, addition: () -> Content)
A value describing the complete replacement of the contents of the indicated group with the given views.

init(
    replacing group: CommandGroupPlacement,
    @ViewBuilder addition: () -> Content
)

Conforms To
Commands

--

struct CommandsBuilder
Constructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.

CommandsBuilder
Constructs command sets from multi-expression closures. Like ViewBuilder, it supports up to ten expressions in the closure body.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

@resultBuilder
struct CommandsBuilder

Building content

static func buildBlock() -> EmptyCommands
Builds an empty command set from a block containing no statements.

buildBlock()
Builds an empty command set from a block containing no statements.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

static func buildBlock() -> EmptyCommands

buildBlock(_:)
Passes a single command group written as a child group through modified.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

static func buildBlock<C>(_ content: C) -> C where C : Commands

static func buildBlock<C>(C) -> C
Passes a single command group written as a child group through modified.

--

static func buildBlock<C0, C1>(C0, C1) -> some Commands

buildBlock(_:_:_:)
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

static func buildBlock<C0, C1, C2>(
    _ c0: C0,
    _ c1: C1,
    _ c2: C2
) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands

--

static func buildBlock<C0, C1, C2>(C0, C1, C2) -> some Commands

static func buildBlock<C0, C1, C2, C3>(C0, C1, C2, C3) -> some Commands

static func buildBlock<C0, C1, C2, C3, C4>(C0, C1, C2, C3, C4) -> some Commands

static func buildBlock<C0, C1, C2, C3, C4, C5>(C0, C1, C2, C3, C4, C5) -> some Commands

static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(C0, C1, C2, C3, C4, C5, C6) -> some Commands

static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(C0, C1, C2, C3, C4, C5, C6, C7) -> some Commands

static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(C0, C1, C2, C3, C4, C5, C6, C7, C8) -> some Commands

static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9) -> some Commands

Building conditionally
static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F>
Produces content for a conditional statement in a multi-statement closure when the condition is true.

buildEither(first:)
Produces content for a conditional statement in a multi-statement closure when the condition is true.
iOS 16.0+
iPadOS 16.0+
Mac Catalyst 16.0+
macOS 13.0+
visionOS 1.0+

static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F> where T : Commands, F : Commands

--

static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F>
Produces content for a conditional statement in a multi-statement closure when the condition is false.

buildEither(second:)
Produces content for a conditional statement in a multi-statement closure when the condition is false.
iOS 16.0+
iPadOS 16.0+
Mac Catalyst 16.0+
macOS 13.0+
visionOS 1.0+

static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F> where T : Commands, F : Commands

--

static func buildIf<C>(C?) -> C?
Produces an optional widget for conditional statements in multi-statement closures that’s only visible when the condition evaluates to true.

buildIf(_:)
Produces an optional widget for conditional statements in multi-statement closures that’s only visible when the condition evaluates to true.
iOS 16.0+
iPadOS 16.0+
Mac Catalyst 16.0+
macOS 13.0+
visionOS 1.0+

static func buildIf<C>(_ content: C?) -> C? where C : Commands

--

static buildLimitedAvailability(_:)
Processes commands for a conditional compiler-control statement that performs an availability check.

buildLimitedAvailability(_:)
Processes commands for a conditional compiler-control statement that performs an availability check.
iOS 17.5+
iPadOS 17.5+
Mac Catalyst 17.5+
macOS 14.5+
visionOS 1.0+

static func buildLimitedAvailability(_ content: any Commands) -> some Commands

--


static func buildExpression<Content>(Content) -> Content
Builds an expression within the builder.

buildExpression(_:)
Builds an expression within the builder.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+

static func buildExpression<Content>(_ content: Content) -> Content where Content : Commands

--

struct CommandGroupPlacement
The standard locations that you can place new command groups relative to.

CommandGroupPlacement
The standard locations that you can place new command groups relative to.
iOS 14.0+
iPadOS 14.0+
Mac Catalyst 14.0+
macOS 11.0+
visionOS 1.0+
struct CommandGroupPlacement

Overview
The names of these placements aren’t visible in the user interface, but the discussion for each placement lists the items that it includes.

App interactions
static let appInfo: CommandGroupPlacement
Placement for commands that provide information about the app, the terms of the user’s license agreement, and so on.

static let appSettings: CommandGroupPlacement
Placement for commands that expose app settings and preferences.

static let appTermination: CommandGroupPlacement
Placement for commands that result in app termination.

static let appVisibility: CommandGroupPlacement
Placement for commands that control the visibility of running apps.

static let systemServices: CommandGroupPlacement
Placement for commands that expose services other apps provide.

File manipulation
static let importExport: CommandGroupPlacement
Placement for commands that relate to importing and exporting data using formats that the app doesn’t natively support.

static let newItem: CommandGroupPlacement
Placement for commands that create different kinds of documents.

static let printItem: CommandGroupPlacement
Placement for commands related to printing app content.

static let saveItem: CommandGroupPlacement
Placement for commands that save open documents and close windows.

Content updates
static let pasteboard: CommandGroupPlacement
Placement for commands that interact with the Clipboard and manipulate content that is currently selected in the app’s view hierarchy.

static let textEditing: CommandGroupPlacement
Placement for commands that manipulate and transform text selections.

static let textFormatting: CommandGroupPlacement
Placement for commands that manipulate and transform the styles applied to text selections.

static let undoRedo: CommandGroupPlacement
Placement for commands that control the Undo Manager.

Bars
static let sidebar: CommandGroupPlacement
Placement for commands that control the app’s sidebar and full-screen modes.

static let toolbar: CommandGroupPlacement
Placement for commands that manipulate the toolbar.

Windows
static let singleWindowList: CommandGroupPlacement
Placement for commands that describe and reveal any windows that the app defines.

static let windowArrangement: CommandGroupPlacement
Placement for commands that arrange all of an app’s windows.

static let windowList: CommandGroupPlacement
Placement for commands that describe and reveal the app’s open windows.

static let windowSize: CommandGroupPlacement
Placement for commands that control the size of the window.

Help
static let help: CommandGroupPlacement
Placement for commands that present documentation and helpful information to people.