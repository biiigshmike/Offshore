Cross-platform SwiftUI design, the Apple way
1) Choose the right scene model
Use App → Scene with WindowGroup for standard multiwindow containers. Keep document-based flows in a dedicated DocumentGroup. 
Structure
@main
struct OffshoreApp: App {
  var body: some Scene {
    WindowGroup("Offshore") {
      RootView()
    }
    // Optional: dedicated document scene if you actually open files
    // DocumentGroup(newDocument:) { DocView($0) }
  }
}
2) Size classes drive adaptive layout
Build layout decisions from size classes rather than device checks. They reflect orientation, multitasking splits, and platform idiom. In SwiftUI, read horizontalSizeClass and verticalSizeClass from the environment. The HIG layout chapter explains when to switch patterns. Apple Developer+1
Pattern
struct AdaptiveGrid: View {
  @Environment(\.horizontalSizeClass) private var h

  var columns: [GridItem] {
    h == .compact ? [GridItem(.flexible())]
                  : [GridItem(.flexible()), GridItem(.flexible())]
  }

  var body: some View {
    ScrollView { LazyVGrid(columns: columns) { /* cells */ } }
  }
}
3) Toolbars that feel native on each platform
Add actions via .toolbar { ToolbarItem(placement: ...) { ... } } and let SwiftUI place them correctly per platform. Enable user customization on macOS with ToolbarCustomizationOptions.
Pattern

.toolbar {
  ToolbarItem(placement: .navigationBarTrailing) { AddButton() }   // iOS/iPad
  ToolbarItem(placement: .automatic) { SettingsButton() }          // becomes a toolbar item on Mac
}

4) Mac Catalyst specifics (design + polish)
Start with the Mac Catalyst HIG to adjust spacing, keyboard shortcuts, and window behaviors so the app feels at home on macOS, not just an up-scaled iPad. Pair that with UIKit’s Mac Catalyst docs for API details and entitlement knobs. 
Useful switches

#if targetEnvironment(macCatalyst)
  // Mac-specific tweaks: command menu, window size, titlebar, etc.
#endif

#if os(iOS)
// iPhone/iPad specific
#endif

Availability checks

if #available(iOS 26, macCatalyst 26, macOS 26, *) {
  // Newer behaviors (e.g., updated chrome or glass tuning)
} else {
  // Legacy fallbacks
}

(You can include macCatalyst alongside iOS/macOS in availability checks when behavior differs on Catalyst.)

5) Windowing and multi-window behavior (Mac & iPad)
Use multiple WindowGroups to create distinct workspaces or launch contexts. For document workflows, keep them in DocumentGroup rather than mixing ad-hoc file pickers into your main WindowGroup. 
6) Content vs chrome: keep hierarchy obvious
HIG: Layout and materials should separate content from chrome. Favor system toolbar/navigation defaults, then refine. Avoid hard-coding paddings and magic numbers that break on other size classes. 
7) A minimal cross-platform scaffold:
App/
  OffshoreApp.swift            // App + Scenes (WindowGroup, optional DocumentGroup)
  Root/
    RootView.swift             // NavigationSplitView shell
    Sidebar.swift              // List/outline; selection binding
    Detail.swift               // Routed detail; hosts a NavigationStack
  CommonUI/
    AdaptiveGrid.swift         // Size-class driven grid
    PrimaryButtonStyle.swift   // Reusable button style (Material-aware)
  Platform/
    Mac/
      CatalystTweaks.swift     // #if targetEnvironment(macCatalyst)
    iOS/
      PhoneAdjustments.swift   // compact-class adjustments
Principles baked in
Scene-first app, no ad-hoc window hacks. 
Split-view root that collapses cleanly. 
Size-class responsive layout, not device branching. 
Toolbar items declared once, adapted per platform. 
Catalyst polish behind compile-time and availability gates. 

Drive all major layout choices from size classes. No device-name switches. 
Declare toolbars once, let placements adapt per platform, enable toolbar customization on Mac. 
Gate platform quirks with #if targetEnvironment(macCatalyst) and #available(...). Keep one primary code path. 
Prefer WindowGroup/DocumentGroup to model multiwindow and document flows, not custom managers. 
Avoid magic numbers. Follow HIG layout spacing and scale with size classes. 



