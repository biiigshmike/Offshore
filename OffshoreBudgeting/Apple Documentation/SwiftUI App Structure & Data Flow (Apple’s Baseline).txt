1. SwiftUI App Structure & Data Flow (Apple’s Baseline)
Before diving into more complex architectures, understand how Apple expects a SwiftUI app to be composed. Their tutorials and API docs imply certain “default” flows. Apple Developer
1.1 App → Scene → View
In SwiftUI, your entry point is an @main struct conforming to App. That defines one or more Scenes (e.g. WindowGroup, DocumentGroup, etc.).
Scenes host Views. Views describe UI declaratively and rely on state/data to render themselves. Apple Developer
The layering is intentionally simple: the App defines high-level structure and environment, and views do the rendering and interactivity.
1.2 Managing Model Data in SwiftUI
Apple’s “Managing model data in your app” doc is a canonical source for how data flows. Apple Developer Key takeaways:
Use @State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject appropriately to connect views and models.
Data changes automatically drive UI updates. There is a unidirectional flow: state → view.
Keep views as “dumb as possible” — they should not hold heavy logic or mutate state in complex ways.
Use @MainActor for classes that will interact with the UI.
Also, Apple’s tutorials show passing data via Bindings between parent and child view to keep things decoupled. 
2. Recommended Architectural Patterns
Apple doesn’t rigidly enforce one architecture (MVC, MVVM, etc.) in the docs, but the community — and many Apple sample projects — lean toward MVVM (Model-View-ViewModel) or variants, especially for SwiftUI. That said, there is no “Apple-official MVVM template” per se.
Below is a refined version, suitable for Codex to learn.
2.1 MVVM (Model-View-ViewModel) in SwiftUI
Core idea: separate UI (View) from state & logic (ViewModel) and pure data (Model).
Model: Simple data types (structs or classes) representing your domain. Contains business logic where appropriate (validation, transformations).
ViewModel: A class (often ObservableObject) that holds state and logic for a particular view or small group of views. The view observes changes in it.
View: Uses @ObservedObject or @StateObject ViewModel to drive UI. It binds to and displays the ViewModel’s published properties, and sends user intents/actions to it.
Advantages:
View is “stateless” in logic (only UI concerns).
Easier to test ViewModel in isolation.
Clear separation of concerns.
Reusable across different UI representations (e.g. SwiftUI, UIKit wrappers).
Best practices / caveats:
Don’t let ViewModel become a “god object.” Single responsibility still applies. Keep ViewModel small and focused.
Use dependency injection for services (network, persistence) so ViewModel can be tested or mocked.
Use @Published or @MainActor to ensure UI coherence.
For complex apps, break down ViewModel further (sub-ViewModels, services, coordinators).
Watch out for over-engineering: not every simple view needs its own ViewModel. Some Apple engineers warn that using MVVM everywhere leads to needless complexity.
Example (simplified)

// Model
struct TodoItem: Identifiable {
  let id: UUID
  var title: String
  var completed: Bool
}

// ViewModel
@MainActor
class TodoListViewModel: ObservableObject {
  @Published var todos: [TodoItem] = []
  private var todoService: TodoServiceProtocol

  init(service: TodoServiceProtocol) {
    self.todoService = service
  }

  func loadTodos() async {
    todos = await todoService.fetchTodos()
  }

  func toggleComplete(item: TodoItem) {
    guard let idx = todos.firstIndex(where: { $0.id == item.id }) else { return }
    todos[idx].completed.toggle()
    // optionally call service to persist
  }
}

// View
struct TodoListView: View {
  @StateObject var vm: TodoListViewModel

  var body: some View {
    List {
      ForEach(vm.todos) { item in
        HStack {
          Text(item.title)
          Spacer()
          Image(systemName: item.completed ? "checkmark.circle" : "circle")
            .onTapGesture {
              vm.toggleComplete(item: item)
            }
        }
      }
    }
    .task {
      await vm.loadTodos()
    }
  }
}

This is the standard “MVVM in SwiftUI” pattern.

2.2 Alternatives & Variations
Because SwiftUI’s data-flow system is more powerful and baked in than UIKit, some developers argue for lighter architectures or modified patterns. A few worth knowing:
“Just use state and environment, no formal architecture” Some argue that SwiftUI already gives you a data-driven paradigm and adding extra layers (ViewModel, coordinator) sometimes duplicates what the framework gives inherently. forums.developer.apple.com+2Medium+2
The Composable Architecture (TCA) / Redux-style pattern For large apps, you may adopt TCA (from PointFree) or unidirectional data flow patterns. You define State, Action, Environment, Reducer per feature. Many teams use it for predictable, scalable architecture. Swift Forums
Each feature module includes its own sub-state, actions, effects, views, etc.
File structure often groups feature code together (State, Action, View) for coherence.
Coordinator / Router / Navigation manager Even in SwiftUI, you often need logic to manage navigation flows. A “Coordinator” (or Router) can be responsible for orchestrating which screens show when, passing dependencies, and handling dismissal or deep links. This separates navigation logic from UI or state logic.
Feature Modules / Clean Architecture / Domain layers For very complex apps, you may implement layered architecture: Domain / Use Cases / Repositories / ViewModels / Views. Each layer is decoupled, tested, and modular. The ViewModel or service layer is the bridge between domain logic and UI.

3. OOP / Swift Best Practices (Codex-Friendly)
Here are higher-level patterns and preferences often recommended in Apple / Swift community that help enforce clean, reusable, maintainable code.
3.1 Protocols & Protocol-Oriented Design
Favor defining protocols for behavior rather than using concrete types. Especially for service layers or abstractions (e.g. NetworkClientProtocol, StorageServiceProtocol).
Use protocol extensions for default behavior, so conforming types only need to implement specifics.
Use generics where appropriate to reduce duplication.
This matches Apple’s general encouragement of protocol-oriented design (especially in Swift) though not always explicitly documented.
3.2 Value Types (Structs) for Data, Classes for State
Use struct for your models and small data containers because of value semantics (avoid shared mutable state).
Use class for stateful objects, e.g. ObservableObject, because they need reference semantics, lifecycle management, shared ownership, etc.
Be careful with @Published and object mutation; always wrap in MainActor where interacting with UI.
3.3 Dependency Injection & Inversion of Control
Don’t build dependencies inside ViewModels or services statically; inject them (via init or via environment) so you can swap mocks for tests or previews.
This lets Codex or you reuse modules in tests, previews, or multiple contexts without rewriting.
3.4 Concurrency & Async / Actors
Use Swift’s structured concurrency (async/await) for asynchronous operations.
Wrap UI-touching code inside @MainActor (or dispatch to MainActor.run { … }) so you don’t violate thread safety.
Consider using actor types for data stores or model synchronization (if needed) to prevent data races.
When combining @Published and async flows, make sure to publish on main thread.
3.5 View Composition & Reusability
Break screens into small reusable view components (subviews) rather than monolithic Views.
Pass only needed data & callbacks to child views; avoid letting a child view reach into parent’s state deeply.
Use ViewModifiers or custom modifiers for styling or repeated layout patterns.
Use theming or environment to inject design constants (colors, spacing) so you're consistent across views.
3.6 Navigation & State / Routing
Don’t let views manage both content and navigation logic. Delegate routing to coordinators, view models, or environment objects.
Use NavigationStack / NavigationPath in newer SwiftUI to have programmatic navigation. Store path state in a ViewModel.
Keep navigation identifiers type-safe (e.g. enums) rather than raw strings.
3.7 Error Handling & Side Effects
Side effects (networking, disk I/O) should not be in the View. They should reside in services invoked by ViewModels or domain layers.
Use Result, async throws, or Combine / AsyncStreams to encapsulate asynchronicity.
Gracefully handle errors by exposing error states in ViewModel, and letting the View show UI accordingly (alerts, fallback UI).
3.8 Testing Considerations
Make your ViewModel and service abstractions testable (no direct reliance on singletons).
Favor pure functions / stateless logic inside models or utility functions (easy to unit test).
Use mocks or fakes for network or persistence services and inject them.
For SwiftUI Views, use previews or snapshot tests; keep the view logic minimal so you test via the ViewModel

4. Example Architecture Sketch for a Feature (Codex-Ready)
Here’s a modular sketch:
FeatureX/
  Models/
    FeatureXModel.swift
  Services/
    FeatureXServiceProtocol.swift
    FeatureXService.swift
  ViewModels/
    FeatureXViewModel.swift
  Views/
    FeatureXView.swift
    SubcomponentView.swift
  Coordinator/
    FeatureXCoordinator.swift

FeatureXService implements FeatureXServiceProtocol that provides operations needed (API, DB).
FeatureXViewModel is @MainActor and ObservableObject. It holds @Published var state: FeatureXState, and maybe @Published var error: Error?.
FeatureXView takes a @StateObject var vm: FeatureXViewModel, binds to vm.state, and calls vm methods on user actions.
FeatureXCoordinator (if needed) handles navigation logic (e.g. pushing a detail view) using dependency injection to construct next view/VM.
